'use strict';

const depd = require('depd')('egg-logger');
const FileTransport = require('./file');
const utils = require('../utils');

/**
 * extends from {@link FileTransport}
 * save log in memory and flush to log file at intervals
 */
class FileBufferTransport extends FileTransport {

  /**
   * @constructor
   * @param {Object} options
   * - {String} file - log file path
   * - {Number} [flushInterval = 1000] - interval for flush to file
   * - {Number} [maxBufferLength = 1000] - max buffer queue length
   * - {String} [level = INFO] - log level
   */
  constructor(options) {
    super(options);

    this._bufSize = 0;
    this._buf = [];
    this._timer = this._createInterval();
  }
  // 父类./transport.js上有合并defaults并赋值给options。
  get defaults() {
    return utils.assign(super.defaults, {
      // 1秒钟刷一次。最大buf长度1000B
      flushInterval: 1000,
      maxBufferLength: 1000,
    });
  }

  /**
   * close stream and interval
   */
  close() {
    this._closeInterval();
    super.close();
  }

  /**
   * @deprecated
   */
  end() {
    depd('transport.end() is deprecated, use transport.close()');
    this.close();
  }

  /**
   * flush log into file
   */
  flush() {
    // _buf内有内容，流可写。则写入并清空_buf数组
    if (this._buf.length > 0 && this.writable) {
      if (this.options.encoding === 'utf8') {
        this._stream.write(this._buf.join(''));
      } else {
        this._stream.write(Buffer.concat(this._buf, this._bufSize));
      }
      // 一定要归零处理，不然就不是简单的内存泄漏了。。
      this._buf = [];
      this._bufSize = 0;
    }
  }

  /**
   * override, flush before close stream
   * @private
   */
  _closeStream() {
    // FileTransport 在初始化时会 reload，这时 _buf 还未初始化
    if (this._buf && this._buf.length > 0) {
      this.flush();
    }
    super._closeStream();
  }

  /**
   * override, save in memory temporary
   * @param {Buffer} buf - log buffer
   * @private
   */
  _write(buf) {
    // _write是把日志写入 _buf数组中。一般情况下是等到flush动作
    this._bufSize += buf.length;
    this._buf.push(buf);
    // 判断_buf长度是否超出最大限制。是则触发一次flush动作。
    if (this._buf.length > this.options.maxBufferLength) {
      this.flush();
    }
  }

  /**
   * create interval to flush log into file
   * @return {Interval} 定时器
   * @private
   */
  _createInterval() {
    return setInterval(() => this.flush(), this.options.flushInterval);
  }

  /**
   * close interval
   * @private
   */
  _closeInterval() {
    if (this._timer) {
      clearInterval(this._timer);
      this._timer = null;
    }
  }
}

module.exports = FileBufferTransport;
